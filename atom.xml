<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>北风骤起，艳阳高照</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.amulong.xin/"/>
  <updated>2017-07-17T04:33:31.035Z</updated>
  <id>http://www.amulong.xin/</id>
  
  <author>
    <name>阿木隆</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端三剑客-js基础大全</title>
    <link href="http://www.amulong.xin/2017/07/17/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2-js%E5%9F%BA%E7%A1%80%E5%A4%A7%E5%85%A8/"/>
    <id>http://www.amulong.xin/2017/07/17/前端三剑客-js基础大全/</id>
    <published>2017-07-17T04:31:55.000Z</published>
    <updated>2017-07-17T04:33:31.035Z</updated>
    
    <content type="html"><![CDATA[<p>基本类型与引用类型的区别<br>1.基本类型： string,number,boolean,null,undefined;操作和保存在变量的实际的值。<br>2.引用类型： Function,Array,Object;值保存在内存中，js不允许直接访问内存，在操作的时候，操作的是对象的引用。</p>
<a id="more"></a>
<h4 id="1-javascript的数组API"><a href="#1-javascript的数组API" class="headerlink" title="1.javascript的数组API"></a>1.javascript的数组API</h4><pre><code>//定义数组 
var arr = new Array();  

//数组长度 
pageIds.length; 

//shift：删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined 
var a = [1,2,3,4,5]; 
var b = a.shift(); //a：[2,3,4,5] b：1 

//unshift：将参数添加到原数组开头，并返回数组的长度 
//注：在IE6.0下测试返回值总为undefined，FF2.0下测试返回值为7，
//所以这个方法的返回值不可靠，需要用返回值时可用splice代替本方法来使用。
var a = [1,2,3,4,5]; 
var b = a.unshift(-2,-1); //a：[-2,-1,1,2,3,4,5] b：7 

//pop：删除原数组最后一项，并返回删除元素的值；如果数组为空则返回undefined 
var a = [1,2,3,4,5]; 
var b = a.pop(); //a：[1,2,3,4] b：5 

//push：将参数添加到原数组末尾，并返回数组的长度 
var a = [1,2,3,4,5]; 
var b = a.push(6,7); //a：[1,2,3,4,5,6,7] b：7 

//concat：返回一个新数组，是将参数添加到原数组中构成的 
var a = [1,2,3,4,5]; 
var b = a.concat(6,7); //a：[1,2,3,4,5] b：[1,2,3,4,5,6,7] 

//splice(start,deleteCount,val1,val2,)：从start位置开始删除deleteCount项，从该位置起插入val1,val2, 
var a = [1,2,3,4,5]; 
var b = a.splice(2,2,7,8,9); //a：[1,2,7,8,9,5] b：[3,4] 
var b = a.splice(0,1); //同shift 
a.splice(0,0,-2,-1); var b = a.length; //同unshift 
var b = a.splice(a.length-1,1); //同pop 
a.splice(a.length,0,6,7); var b = a.length; //同push 

//reverse：将数组反序 
var a = [1,2,3,4,5]; 
var b = a.reverse(); //a：[5,4,3,2,1] b：[5,4,3,2,1] 

//sort(orderfunction)：按指定的参数对数组进行排序 
var a = [1,2,3,4,5]; 
var b = a.sort(); //a：[1,2,3,4,5] b：[1,2,3,4,5] 

//slice(start,end)：返回从原数组中指定开始下标到结束下标之间的项组成的新数组 
var a = [1,2,3,4,5]; 
var b = a.slice(2,5); //a：[1,2,3,4,5] b：[3,4,5] 

//join(separator)：将数组的元素组起一个字符串，以separator为分隔符，省略的话则用默认用逗号为分隔符 
var a = [1,2,3,4,5]; 
var b = a.join(&quot;|&quot;); //a：[1,2,3,4,5] b：&quot;1|2|3|4|5&quot; 
</code></pre><h4 id="2-dom最常用API"><a href="#2-dom最常用API" class="headerlink" title="2.dom最常用API"></a>2.dom最常用API</h4><pre><code>//document方法： 
getElementById(id) Node 返回指定节点的引用 
getElementsByTagName(name) NodeList 返回文档中所有匹配的元素的集合 
createElement(name) Node 创建一个元素节点
createTextNode(text) 创建一个纯文本结点 
ownerDocument Document 指向这个节点所属的文档 
documentElement Node 返回html节点 
document.body Node 返回body节点 

//element方法： 
getAttribute(attributeName) String 返回指定属性的值 
setAttribute(attributeName,value) String 给属性赋值 
removeAttribute(attributeName) String 移除指定属性和它的值 

//node方法： 
appendChild(child) Node 给指定结点添加一个新的子结点 
removeChild(child) Node 移除指定结点的子结点 
replaceChild(newChild,oldChild) Node 替换指定结点的子结点 
insertBefore(newChild,refChild) Node 在同一层级的结点前面插入新结点 
hasChildNodes() Boolean 如果结点有子结点则返回true 

//node属性： 
nodeName String 以字符串的格式存放结点的名称 
nodeType String 以整型数据格式存放结点的类型 
nodeValue String 以可用的格式存放结点的值 
parentNode Node 指向结点的父结点的引用 
childNodes NodeList 指向子结点的引用的集合 
firstChild Node 指向子结点结合中的第一个子结点的引用 
lastChild Node 指向子结点结合中的最后一个子结点的引用 
previousSibling Node 指向前一个兄弟节点；如果这个节点就是兄弟节点，那么该值为null 
nextSibling Node 指向后一个兄弟节点；如果这个节点就是兄弟节点，那么该值为null
</code></pre><h4 id="3-创建一个map对象"><a href="#3-创建一个map对象" class="headerlink" title="3.创建一个map对象:"></a>3.创建一个map对象:</h4><pre><code>function HashMap() { 
    /** Map 大小 **/ 
    var size = 0; 
    /** 对象 **/ 
    var entry = new Object(); 
    /** 存 **/ 
    this.put = function (key , value) { 
        if(!this.containsKey(key)) { 
            size ++ ; 
        } 
        entry[key] = value; 
    } 
    /** 取 **/ 
    this.get = function (key) { 
        return this.containsKey(key) ? entry[key] : null; 
    } 
    /** 删除 **/ 
    this.remove = function ( key ) { 
        if( this.containsKey(key) &amp;&amp; ( delete entry[key] ) ) { 
            size --; 
        } 
    } 
    /** 是否包含 Key **/ 
    this.containsKey = function ( key ) { 
        return (key in entry); 
    } 
    /** 是否包含 Value **/ 
    this.containsValue = function ( value )     { 
        for(var prop in entry)  { 
            if(entry[prop] == value)    { 
                return true; 
            } 
        } 
        return false; 
    } 
    /** 所有 Value **/ 
    this.values = function () { 
        var values = new Array(); 
        for(var prop in entry) { 
            values.push(entry[prop]); 
        } 
        return values; 
    } 
    /** 所有 Key **/ 
    this.keys = function () { 
        var keys = new Array(); 
        for(var prop in entry) { 
            keys.push(prop); 
        } 
        return keys;   
    } 
    /** Map Size **/ 
    this.size = function () { 
        return size; 
    } 
    /* 清空 */ 
    this.clear = function () { 
        size = 0; 
        entry = new Object(); 
    } 
} 
var map = new HashMap(); 
/* 
    map.put(&quot;A&quot;,&quot;1&quot;); 
    map.put(&quot;B&quot;,&quot;2&quot;); 
    map.put(&quot;A&quot;,&quot;5&quot;); 
*/ 
/* 
    alert(map.containsKey(&quot;XX&quot;)); 
    alert(map.size()); 
    alert(map.get(&quot;A&quot;)); 
    alert(map.get(&quot;XX&quot;)); 
    map.remove(&quot;A&quot;); 
    alert(map.size()); 
    alert(map.get(&quot;A&quot;)); 
*/ 
/** 同时也可以把对象作为 Key **/ 
/* 
    var arrayKey = new Array(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;); 
    var arrayValue = new Array(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;); 
    map.put(arrayKey,arrayValue); 
    var value = map.get(arrayKey); 
    for(var i = 0 ; i &lt; value.length ; i++) { 
        //alert(value[i]); 
    } 
*/ 
/** 把对象做为Key时，自动调用了该对象的toString()方法其实最终还是以String对象为Key**/ 
/** 如果是自定义对象 那自己得重写 toString() 方法 否则就是下面的结果 **/ 
function MyObject(name){ 
    this.name = name; 
} 
/** 
function MyObject(name) { 
    this.name = name; 
    this.toString = function () { 
        return this.name; 
    } 
} 
**/ 
var object1 = new MyObject(&quot;小张&quot;); 
var object2 = new MyObject(&quot;小名&quot;); 
map.put(object1,&quot;小张&quot;); 
map.put(object2,&quot;小名&quot;); 
alert(map.get(object1)); 
alert(map.get(object2)); 
map.remove(&quot;xxxxx&quot;); 
alert(map.size()); 
/** 运行结果 小名 小名 size = 1 **/ 
/** 如果改成复写toString()方法的对象 , 效果就完全不一样了 **/ 
</code></pre><h4 id="4-常用的数字函数"><a href="#4-常用的数字函数" class="headerlink" title="4.常用的数字函数:"></a>4.常用的数字函数:</h4><pre><code>//数字型(Number) 
//1.声明 
var i = 1; 
var i = new Number(1); 

//2.字符串与数字间的转换 
var i = 1; 
var str = i.toString(); //结果: &quot;1&quot; 
var str = new String(i); //结果: &quot;1&quot; 
i = parseInt(str); //结果: 1 
i = parseFloat(str); //结果: 1.0 
//注意: parseInt,parseFloat会把一个类似于&quot;32G&quot;的字符串,强制转换成32 

//3.判断是否为有效的数字 
var i = 123; var str = &quot;string&quot;; 
if( typeof i == &quot;number&quot; ){ } //true 
//某些方法(如:parseInt,parseFloat)会返回一个特殊的值NaN(Not a Number) 
//请注意第2点中的[注意],此方法不完全适合判断一个字符串是否是数字型!! 
i = parseInt(str); 
if( isNaN(i) ){ } 

//4.数字型比较 
//此知识与[字符串比较]相同 

///5.小数转整数 
var f = 1.5; 
var i = Math.round(f); //结果:2 (四舍五入) 
var i = Math.ceil(f); //结果:2 (返回大于f的最小整数) 
var i = Math.floor(f); //结果:1 (返回小于f的最大整数) 

//6.格式化显示数字 
var i = 3.14159; 
//格式化为两位小数的浮点数 
var str = i.toFixed(2); //结果: &quot;3.14&quot; 
//格式化为五位数字的浮点数(从左到右五位数字,不够补零) 
var str = i.toPrecision(5); //结果: &quot;3.1415&quot; 

//7.X进制数字的转换 
var i = parseInt(&quot;0x1f&quot;,16); 
var i = parseInt(i,10); 
var i = parseInt(&quot;11010011&quot;,2); 

//8.随机数 
//返回0-1之间的任意小数 
var rnd = Math.random(); 
//返回0-n之间的任意整数(不包括n) 
var rnd = Math.floor(Math.random() * n) 
</code></pre><h4 id="5-js堆栈"><a href="#5-js堆栈" class="headerlink" title="5.js堆栈:"></a>5.js堆栈:</h4><pre><code>function stack(){ 
    if(this.top==undefined){ 
        //初始化堆栈的顶部指针和数据存放域 
        this.top=0; 
        this.unit=new Array(); 
    } 
    this.push=function(pushvalue){ 
        //定义压入堆栈的方法 
        this.unit[this.top]=pushvalue; 
        this.top+=1; 
    } 
    this.readAllElements=function(){ 
        //定义读取所有数据的方法 
        if(this.top==0){ 
            alert(&quot;当前栈空，无法读取数据&quot;); 
            return(&quot;&quot;); 
        } 
        var count=0; 
        var outStr=&quot;&quot;; 
        for(count=0;count&lt;this.top;count++){ 
            outStr+=this.unit[count]+&quot;,&quot;; 
        } 
        return(outStr); 
    } 
    this.pop=function(){ 
        //定义弹出堆栈的方法 
        if(this.top==0){ 
            alert(&quot;当前栈空，无法弹出数据&quot;); 
            return(&quot;&quot;); 
        } 
        var popTo=this.unit[this.top-1]; 
        this.top--; 
        return(popTo); 
    /* 从堆栈弹出数据，顶部指针减一，不过这里没有做到资源的释放，也 
    就是说数据仍然存在于this.unit的数组中，只不过无法访问罢了。目前 
    我也没想到好的办法解决。*/ 
    } 
} 
</code></pre><h4 id="6-JavaScript日期函数"><a href="#6-JavaScript日期函数" class="headerlink" title="6.JavaScript日期函数:"></a>6.JavaScript日期函数:</h4><pre><code>//日期型(Date) 
//1.声明 
var myDate = new Date(); //系统当前时间 
var myDate = new Date(yyyy, mm, dd, hh, mm, ss); 
var myDate = new Date(yyyy, mm, dd); 
var myDate = new Date(&quot;monthName dd, yyyy hh:mm:ss&quot;); 
var myDate = new Date(&quot;monthName dd, yyyy&quot;); 
var myDate = new Date(epochMilliseconds); 

//2.获取时间的某部份 
var myDate = new Date(); 
myDate.getYear(); //获取当前年份(2位) 
myDate.getFullYear(); //获取完整的年份(4位,1970-????) 
myDate.getMonth(); //获取当前月份(0-11,0代表1月) 
myDate.getDate(); //获取当前日(1-31) 
myDate.getDay(); //获取当前星期X(0-6,0代表星期天) 
myDate.getTime(); //获取当前时间(从1970.1.1开始的毫秒数) 时间戳！！ 
myDate.getHours(); //获取当前小时数(0-23) 
myDate.getMinutes(); //获取当前分钟数(0-59) 
myDate.getSeconds(); //获取当前秒数(0-59) 
myDate.getMilliseconds(); //获取当前毫秒数(0-999) 
myDate.toLocaleDateString(); //获取当前日期 
myDate.toLocaleTimeString(); //获取当前时间 
myDate.toLocaleString( ); //获取日期与时间 

//3.计算之前或未来的时间 
var myDate = new Date(); 
myDate.setDate(myDate.getDate() + 10); //当前时间加10天 
//类似的方法都基本相同,以set开头,具体参考第2点 

//4.计算两个日期的偏移量 
var i = daysBetween(beginDate,endDate); //返回天数 
var i = beginDate.getTimezoneOffset(endDate); //返回分钟数 

//5.检查有效日期 
//checkDate() 只允许&quot;mm-dd-yyyy&quot;或&quot;mm/dd/yyyy&quot;两种格式的日期 
if( checkDate(&quot;2006-01-01&quot;) ){ } 
//正则表达式(自己写的检查 yyyy-mm-dd, yy-mm-dd, yyyy/mm/dd, yy/mm/dd 四种) 
var r = /^(\d{2}|\d{4})[\/-]\d{1,2}[\/-]\d{1,2}$/; 
if( r.test( myString ) ){ } 
</code></pre><h4 id="7-最常用字符串函数API"><a href="#7-最常用字符串函数API" class="headerlink" title="7.最常用字符串函数API:"></a>7.最常用字符串函数API:</h4><pre><code>//字符串(String) 
//1.声明 
var myString = new String(&quot;Every good boy does fine.&quot;); 
var myString = &quot;Every good boy does fine.&quot;; 

//2.字符串连接 
var myString = &quot;Every &quot; + &quot;good boy &quot; + &quot;does fine.&quot;; 
var myString = &quot;Every &quot;; myString += &quot;good boy does fine.&quot;; 

//3.截取字符串 
var myString = &quot;Every good boy does fine.&quot;; 
//截取第 6 位开始的字符 
var section = myString.substring(6); //结果: &quot;good boy does fine.&quot; 
//截取第 0 位开始至第 10 位为止的字符 
var section = myString.substring(0,10); //结果: &quot;Every good&quot; 
//截取从第 11 位到倒数第 6 位为止的字符 
var section = myString.slice(11,-6); //结果: &quot;boy does&quot; 
//从第 6 位开始截取长度为 4 的字符 
var section = myString.substr(6,4); //结果: &quot;good&quot; 

//4.转换大小写 
var myString = &quot;Hello&quot;; 
var lcString = myString.toLowerCase(); //结果: &quot;hello&quot; 
var ucString = myString.toUpperCase(); //结果: &quot;HELLO&quot; 

//5.字符串比较 
var aString = &quot;Hello!&quot;; 
var bString = new String(&quot;Hello!&quot;); 
if( aString == &quot;Hello!&quot; ){ } //结果: true 
if( aString == bString ){ } //结果: true 
if( aString === bString ){ } //结果: false (两个对象不同,尽管它们的值相同) 

//6.检索字符串 
var myString = &quot;hello everybody.&quot;; 
// 如果检索不到会返回-1,检索到的话返回在该串中的起始位置 
if( myString.indexOf(&quot;every&quot;) &gt; -1 ){ } //结果: true 

////7.查找替换字符串 
var myString = &quot;I is your father.&quot;; 
var result = myString.replace(&quot;is&quot;,&quot;am&quot;); //结果: &quot;I am your father.&quot; 

//8.特殊字符: 
//\b : 后退符 \t : 水平制表符 
//\n : 换行符 \v : 垂直制表符 
//\f : 分页符 \r : 回车符 
//\&quot; : 双引号 \&apos; : 单引号 
//\\ : 反斜杆 

//9.将字符转换成Unicode编码 
var myString = &quot;hello&quot;; 
var code = myString.charCodeAt(3); //返回&quot;l&quot;的Unicode编码(整型) 
var char = String.fromCharCode(66); //返回Unicode为66的字符 

//10.将字符串转换成URL编码 
var myString = &quot;hello all&quot;; 
var code = encodeURI(myString); //结果: &quot;hello%20all&quot; 
var str = decodeURI(code); //结果: &quot;hello all&quot; 
//相应的还有: encodeURIComponent() decodeURIComponent() 
</code></pre><h4 id="8-数学函数"><a href="#8-数学函数" class="headerlink" title="8.数学函数:"></a>8.数学函数:</h4><pre><code>//Math对象 
1. Math.abs(num) : 返回num的绝对值 
2. Math.acos(num) : 返回num的反余弦值 
3. Math.asin(num) : 返回num的反正弦值 
4. Math.atan(num) : 返回num的反正切值 
5. Math.atan2(y,x) : 返回y除以x的商的反正切值 
6. Math.ceil(num) : 返回大于num的最小整数 
7. Math.cos(num) : 返回num的余弦值 
8. Math.exp(x) : 返回以自然数为底,x次幂的数 
9. Math.floor(num) : 返回小于num的最大整数 
10.Math.log(num) : 返回num的自然对数 
11.Math.max(num1,num2) : 返回num1和num2中较大的一个 
12.Math.min(num1,num2) : 返回num1和num2中较小的一个 
13.Math.pow(x,y) : 返回x的y次方的值 
14.Math.random() : 返回0到1之间的一个随机数 
15.Math.round(num) : 返回num四舍五入后的值 
16.Math.sin(num) : 返回num的正弦值 
17.Math.sqrt(num) : 返回num的平方根 
18.Math.tan(num) : 返回num的正切值 
19.Math.E : 自然数(2.718281828459045) 
20.Math.LN2 : 2的自然对数(0.6931471805599453) 
21.Math.LN10 : 10的自然对数(2.302585092994046) 
22.Math.LOG2E : log 2 为底的自然数(1.4426950408889634) 
23.Math.LOG10E : log 10 为底的自然数(0.4342944819032518) 
24.Math.PI : π(3.141592653589793) 
25.Math.SQRT1_2 : 1/2的平方根(0.7071067811865476) 
26.Math.SQRT2 : 2的平方根(1.4142135623730951) 
</code></pre><h4 id="9-浏览器特征函数"><a href="#9-浏览器特征函数" class="headerlink" title="9.浏览器特征函数:"></a>9.浏览器特征函数:</h4><pre><code>//1.浏览器名称 
//IE : &quot;Microsoft Internet Explorer&quot; 
//NS : &quot;Netscape&quot; 
var browserName = navigator.appName; 

//2.浏览器版本 
var browserVersion = navigator.appVersion; 

//3.客户端操作系统 
var isWin = ( navigator.userAgent.indexOf(&quot;Win&quot;) != -1 ); 
var isMac = ( navigator.userAgent.indexOf(&quot;Mac&quot;) != -1 ); 
var isUnix = ( navigator.userAgent.indexOf(&quot;X11&quot;) != -1 ); 

//4.判断是否支持某对象,方法,属性 
//当一个对象,方法,属性未定义时会返回undefined或null等,这些特殊值都是false 
if( document.images ){ } 
if( document.getElementById ){ } 

//5.检查浏览器当前语言 
if( navigator.userLanguage ){ var l = navigator.userLanguage.toUpperCase(); } 

//6.检查浏览器是否支持Cookies 
if( navigator.cookieEnabled ){ } 
</code></pre><h4 id="10-JavaScript面向对象的方法实现继承-call方法"><a href="#10-JavaScript面向对象的方法实现继承-call方法" class="headerlink" title="10.JavaScript面向对象的方法实现继承:call方法"></a>10.JavaScript面向对象的方法实现继承:call方法</h4><pre><code>// 动物类 animal 
function animal(bSex){ 
    this.sex = bSex 
    this.getSex = function(){ 
        return this.sex 
    } 
} 
// 类静态变量 (如果你不修改它的话～～) 
animal.SEX_G = new Object(); // 雌性 
animal.SEX_B = new Object(); // 雄性 
// 动物子类 鸟 
function bird(bSex){ 
    animal.call(this, bSex); 
    this.fly = function(iSpeed){ 
        alert(&quot;飞行时速高达 &quot; + iSpeed); 
    } 
} 
// 动物子类 鱼 
function fish(bSex){ 
    animal.call(this, bSex); 
    this.swim = function(iSpeed){ 
        alert(&quot;游动时速高达 &quot; + iSpeed) 
    } 
} 
// 鱼 鸟 杂交品种。。。 
function crossBF(bSex){ 
    bird.call(this, bSex); 
    fish.call(this, bSex); 
} 
var oPet = new crossBF(animal.SEX_G); // 雌性 鱼鸟 
alert(oPet.getSex() == animal.SEX_G ? &quot;雌性&quot; : &quot;雄性&quot;); 
oPet.fly(124) 
oPet.swim(254) 
</code></pre><h4 id="11-用面向对象的编程方式写JavaScript"><a href="#11-用面向对象的编程方式写JavaScript" class="headerlink" title="11.用面向对象的编程方式写JavaScript:"></a>11.用面向对象的编程方式写JavaScript:</h4><pre><code>MyTool = new function(){ 
    /** 
    * 返回非空字符串,如果有默认值就返回默认字符串. 
    */ 
    this.notNull = function(str,defaultStr){ 
        if(typeof(str)==&quot;undefined&quot;||str==null||str==&apos;&apos;){ 
            if(defaultStr) {
                return defaultStr; 
            } else {
                return &apos;&apos;; 
            }
        } else{ 
            return str; 
        } 
    } 
} 
rootId = MyTool.notNull(rootId,&apos;001000&apos;); 
</code></pre><h4 id="12-常用的js方法-包括表单校验的一些方法-下拉菜单常用的方法等等"><a href="#12-常用的js方法-包括表单校验的一些方法-下拉菜单常用的方法等等" class="headerlink" title="12.常用的js方法,包括表单校验的一些方法,下拉菜单常用的方法等等:"></a>12.常用的js方法,包括表单校验的一些方法,下拉菜单常用的方法等等:</h4><pre><code>/** 
* 对JSON对象转换为字符串. 
* @param {json对象} json 
* @return {json字符串} 
*/ 
function jsonObj2Str(json) { 
    var str = &quot;{&quot;; 
    for (prop in json) { 
        str += prop + &quot;:&quot; + json[prop] + &quot;,&quot;; 
    } 
    str = str.substr(0, str.length - 1); 
    str += &quot;}&quot;; 
    return str; 
} 
/** 
* 将json字符串转换为json对象. 
* @param {json字符串} jsonstr 
* @return {json对象} 
*/ 
function jsonStr2Obj(jsonstr) { 
    return eval(&quot;(&quot;+jsonstr+&quot;)&quot;); 
} 
/** 
* 得到一个元素的left坐标值. 
* @param {dom对象} obj 
* @return {位置值} 
*/ 
function getLeft(obj){ 
    var offset=e.offsetLeft; 
    if(e.offsetParent!=null){
        offset+=getLeft(e.offsetParent); 
    } 
    return offset; 
} 
/** 
* 得到一个元素的绝对位置的top坐标值. 
* @param {dom对象} obj 
* @return {位置值} 
*/ 
function getTop(obj){ 
    var offset=e.offsetTop; 
    if(e.offsetParent!=null) {
        offset+=getTop(e.offsetParent); 
    }
    return offset; 
} 
/** 
* 删除一个字符串的左右空格. 
* @param {原始字符串} str 
* @return {删除空格之后的字符串} 
*/ 
function trim(str) { 
    return str.replace(/(^\s*)|(\s*$)/g,&quot;&quot;); 
} 
/** 
* 根据id取出一个元素. 
* @param {元素id值} str 
* @return {dom对象} 
*/ 
function $(str) { 
    return document.getElementById(str); 
} 
/** 
* 按name获取一个对象. 
* @param {元素name值} str 
* @return {根据name返回的第一个对象} 
*/ 
function $byName(str) { 
    var arr = document.getElementsByName(str); 
    if (arr) {
        return arr[0]; 
    }else {
        return null; 
    } 
} 
/***************以下方法和表单验证相关*************************************************/ 
/** 
* 返回非空字符串,如果有默认值就返回默认字符串. 
* @param {要进行转换的原字符串} str 
* @param {默认值} defaultStr 
* @return {返回结果} 
*/ 
function notNull(str, defaultStr) { 
    if (typeof(str) == &quot;undefined&quot; || str == null || str == &apos;&apos;) { 
        if (defaultStr) {
            return defaultStr; 
        }else{ 
            return &apos;&apos;;
        } 
    } else { 
        return str; 
    } 
} 
/** 
* 比较两个日期大小. 
* @param {较小日期的文本框id} smallDate 
* @param {较大日期的文本框id} bigDate 
* @param {出错的提示信息} msg 
*/ 
function compareTwoDate(smallDate, bigDate, msg) { 
    var v1 = $(smallDate).value; 
    var v2 = $(bigDate).value; 
    if (v1 &gt;= v2) { 
        alert(msg); 
        v2.focus(); 
        return false; 
    } 
    return true; 
} 
/** 
* 比较两个金额大小的方法. 
* @param {较小的金额} smallNum 
* @param {较大的金额} bigNum 
* @param {出错提示信息} msg 
* @return {Boolean} 
*/ 
function compareTwoNum(smallNum, bigNum, msg) { 
    var v1 = $(smallNum).value; 
    var v2 = $(bigNum).value; 
    if (parseFloat(v1) &gt;= parseFloat(v2)) { 
        alert(msg); 
        v2.focus(); 
        return false; 
    } 
    return true; 
} 
/** 
* 检查文本框的长度是否超出指定长度. 
* @param {文本id} textId 
* @param {文本框的最大长度} len 
* @param {文本框描述内容} msg 
* @return {有错就返回false,否则返回true} 
*/ 
function checkLength(textId, len, msg) { 
    obj = $(textId); 
    str = obj.value; 
    str = str.replace(/[^\x00-\xff]/g, &quot;**&quot;); 
    realLen = str.length; 
    if (realLen &gt; len) { 
        alert(&quot;[&quot; + msg + &quot;]&quot; + &quot;长度最大为&quot; + len + &quot;位,&quot; + &quot;请重新输入！\n注意：一个汉字占2位。&quot;); 
        obj.focus(); 
        return false; 
    } else {
        return true;
    }
} 
/** 
* 判断某个文本框不可以为空. 
* @param {文本框id} textId 
* @param {文本框描述内容} msg 
* @return {有错就返回false,否则返回true} 
*/ 
function checkIfEmpty(textId, msg) { 
    var textObj = $(textId); 
    var textValue = textObj.value; 
    if (trim(textValue) == &apos;&apos;) { 
        alert(&apos;[&apos; + msg + &apos;]不得为空！&apos;); 
        textObj.focus(); 
        return false; 
    } else { 
        return true; 
    } 
} 
/** 
* 判断指定文本框内容必须为邮件. 
* @param {文本框id} textId 
* @param {文本框描述} msg 
* @return {如果是邮件内容就返回true否则返回false} 
*/ 
function checkIsMail(textId, msg) { 
    var obj = $(textId); 
    if (!_isEmail(obj.value)) { 
        alert(&apos;[&apos; + msg + &apos;]不是合法的邮件地址！&apos;); 
        obj.focus(); 
        return false;   
    } else 
    return true; 
} 
/** 
* 验证是不是邮件. 
* @param {要验证的字符串} strEmail 
* @return {Boolean} 
*/ 
function _isEmail(strEmail) { 
    //接下来的验证是否有两个以上的‘.&apos;号，有的话就是错的！ 
    var first = strEmail.indexOf(&apos;.&apos;); 
    if (strEmail.indexOf(&apos;@&apos;)== -1) { 
        return false; 
    } 
    var tempStr = strEmail.substring(first + 1); 
    if (tempStr.indexOf(&apos;.&apos;) != -1) { 
        return false; 
    } 
    if (strEmail 
    .search(/^\w+((-\w+)|(\.\w+))*\@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/) != -1) { 
        return true; 
    } else {
        return false;        
    }
} 
/** 
* 判断某个文本框是否数字. 
* @param {文本框id} textId 
* @param {文本框描述内容} msg 
* @return {Boolean} 
*/ 
function checkIsNum(textId, msg) { 
    obj = $(textId); 
    if (isNaN(obj.value)) { 
        alert(&apos;[&apos; + msg + &apos;]必须为数字。&apos;); 
        obj.focus(); 
        return false; 
    } else {
        return true;        
    }
} 
/** 
* 判断某个文本框是否含有非法字符. 
* @param {文本框的id} textId 
* @param {文本框描述内容} msg 
* @return {有错就返回false否则返回true} 
*/ 
function checkIsValid(textId, msg) { 
    obj = $(textId); 
    if (!_isValidString(obj.value, &apos;[&apos; + msg + &apos;]不得含有非法字符。&apos;)) { 
        obj.focus(); 
        return false; 
    } 
    return true; 
} 
/** 
* 判断是不是合法字符串. 
* @param {要进行判断的字符串} szStr 
* @param {文本描述} errMsg 
* @return {合法则返回true否则返回false} 
*/ 
function _isValidString(szStr,errMsg) { 
    voidChar = &quot;&apos;\&quot;&gt;&lt;`~!@#$%^&amp;\(\)（）！￥……？?“”‘&apos;*&quot;; 
    for (var i = 0; i &lt; voidChar.length; i++) { 
        aChar = voidChar.substring(i, i + 1); 
        if (szStr.indexOf(aChar) &gt; -1){ 
            alert(errMsg) 
            return false; 
        } 
    } 
    return true; 
} 
/*************** 以下方法和下拉菜单相关*************************************************/ 
/** 
* 控制下拉菜单不可以为-1(未选择情况value=-1) 
* @param {下拉菜单id} selectId 
* @param {下拉菜单描述内容} msg 
* @param {下拉菜单的空值对应的value,默认为-1} nullValue 
* @return {Boolean} 
*/ 
function checkChooseSelect(selectId, msg ,nullValue) { 
    var obj = $(selectId); 
    if (obj.value == notNull(nullValue,&apos;-1&apos;)) { 
        alert(&apos;[&apos; + msg + &apos;]必选!&apos;); 
        obj.focus(); 
        return false; 
    }
    return true; 
} 
/** 
* 得到下拉菜单的显示的文字. 
* @param {下拉菜单dom对象} selectObj 
* @return {返回下拉菜单的显示的&quot;文本&quot;} 
*/ 
function getSelectText(selectObj) { 
    return selectObj.options[selectObj.selectedIndex].text; 
} 
/** 
* 得到下拉菜单的显示的值. 
* @param {下拉菜单dom对象} selectObj 
* @return {得到下拉菜单的显示的&quot;值&quot;} 
*/ 
function getSelectValue(selectObj) { 
    return selectObj.options[selectObj.selectedIndex].value; 
} 
/** 
* 设置下拉菜单的选择状态到指定的值. 
* @param {下拉菜单对象} obj 
* @param {要选择的值} value 
*/ 
function setSelectValue(obj, value) { 
    /*
    for (i = obj.options.length - 1; i &gt;= 0; i--) { 
        if (obj.options[i].value == value) { 
            obj.options[i].selected = true; 
            return; 
        } 
    } 
    */ 
    obj.value= value; 
} 
/** 
* 根据键值串的内容进行下拉菜单的动态组装 
* @param {要进行下拉菜单组装的dom对象} obj 
* @param {键值对用,和;分割,例如&apos;1,男;2,女;3,未知&apos;} valAndText 
*/ 
function setSelectContent(obj,valAndText){ 
    if(trim(valAndText)==&apos;&apos;){ 
        alert(&apos;没有要进行组装下拉菜单的数据!&apos;); 
        return false; 
    } 
    clearSelect(obj); 
    var keyandvalues = valAndText.split(&apos;;&apos;); 
    for(var i=0;i&lt;keyandvalues.length;i++){ 
        var arr = keyandvalues[i].split(&apos;,&apos;); 
        if(arr){ 
            var value =arr[0]; 
            var text =arr[1]; 
            var objOption = new Option(text,value); 
            obj.add(objOption); 
        } 
    } 
} 
/** 
* 清空下拉菜单里面的内容. 
* @param {下拉菜单对象} obj 
*/ 
function clearSelect(obj) { 
    for (var i=obj.options.length; i &gt;0; i--) { 
        obj.remove(0); 
    } 
} 
/*************** 以下方法和多选框相关*************************************************/ 
/** 
* 返回选中的checks的id组成的字符串,逗号隔开. 
* @param {checks数组} checks 
* @return 选择的id组成的字符串 
*/ 
function getCheckedIds(checks){ 
    var selectedValue = &apos;&apos;; 
    var len = checks.length; 
    for(var index=0; index&lt;len; index++) { 
        if(checks[index].checked==true) { 
            selectedValue += checks[index].value+&quot;,&quot;; 
        } 
    } 
    if(selectedValue.length&gt;0) {
        return selectedValue.substring(0,selectedValue.length-1); 
    }
    return selectedValue; 
} 

//下面的代码放到html标签里，并在head里调用上面的js
&lt;HEAD&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
    &lt;!--&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;调用上面的js&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;--&gt;
    &lt;SCRIPT LANGUAGE=&quot;JavaScript&quot;&gt; 
        &lt;!-- 
            /** 
            * 表单验证的示例js方法. 
            */ 
            function check(){ 
                if(checkIfEmpty(&apos;a&apos;,&apos;非空校验&apos;) 
                &amp;&amp;checkIsMail(&apos;b&apos;,&apos;邮箱校验&apos;) 
                &amp;&amp;checkIsNum(&apos;c&apos;,&apos;数字校验&apos;) 
                &amp;&amp;checkIsValid(&apos;d&apos;,&apos;合法性校验&apos;) 
                &amp;&amp;compareTwoDate(&apos;e&apos;,&apos;f&apos;,&apos;小日期与大日期关系错误!&apos;) 
                &amp;&amp;checkLength(&apos;g&apos;,5,&apos;长度校验&apos;) 
                &amp;&amp;checkChooseSelect(&apos;h&apos;,&apos;下拉菜单非空&apos;,&apos;-1&apos;) 
                &amp;&amp;compareTwoNum(&apos;k&apos;,&apos;l&apos;,&apos;大小数目关系不正确!&apos;)){ 
                    alert(&apos;校验通过!&apos;); 
                    return true; 
                }else{ 
                    return false; 
                } 
            } 
            /** 
            * 取下拉菜单的值和文本的示例js方法. 
            */ 
            function getSelect(){ 
                var sss = $(&apos;h&apos;); 
                alert(&apos;下拉菜单选择的文本是:&apos;+getSelectText(sss)+&apos;\n&apos; 
                +&apos;下拉菜单选择的值是:&apos;+getSelectValue(sss)); 
            } 
            /** 
            * 根据键值字符串设置下拉菜单的显示内容. 
            */ 
            function setSelect(){ 
                var sss = $(&apos;i&apos;).value; 
                setSelectContent($(&apos;h&apos;),sss); 
            } 
            /** 
            * 返回多选框数组选择状态的id的字符串,结果以逗号隔开. 
            */ 
            function getMulti(){ 
                alert(&apos;多选选择的id是:&apos;+getCheckedIds(document.getElementsByName(&apos;j&apos;))); 
            } 
        //--&gt; 
    &lt;/SCRIPT&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td&gt; 非空:
          &lt;input id=&apos;a&apos;&gt;&lt;/td&gt;
        &lt;td&gt; checkIfEmpty(&apos;a&apos;,&apos;非空校验&apos;) &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td&gt; 邮箱:
          &lt;input id=&apos;b&apos; value=&apos;323232@2323.com&apos;&gt;&lt;/td&gt;
        &lt;td&gt; checkIsMail(&apos;b&apos;,&apos;邮箱校验&apos;) &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td&gt; 数字:
          &lt;input id=&apos;c&apos; value=&apos;aaaa&apos;&gt;&lt;/td&gt;
        &lt;td&gt; checkIsNum(&apos;c&apos;,&apos;数字校验&apos;) &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td&gt; 合法字符:
          &lt;input id=&apos;d&apos; value=&apos;@$@$#$#!%%#&apos;&gt;&lt;/td&gt;
        &lt;td&gt; checkIsValid(&apos;d&apos;,&apos;合法性校验&apos;) &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td&gt; 小的日期:
          &lt;input id=&apos;e&apos; value=&apos;2010-1-1&apos;&gt;
          大的日期:
          &lt;input id=&apos;f&apos; value=&apos;2011-1-1&apos;&gt;&lt;/td&gt;
        &lt;td&gt; compareTwoDate(&apos;e&apos;,&apos;f&apos;,&apos;小日期与大日期关系错误!&apos;) &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td&gt; 小的数:
          &lt;input id=&apos;k&apos; value=&apos;12.3&apos;&gt;
          大的数:
          &lt;input id=&apos;l&apos; value=&apos;4564&apos;&gt;&lt;/td&gt;
        &lt;td&gt; compareTwoNum(&apos;k&apos;,&apos;l&apos;,&apos;大小数目关系不正确!&apos;) &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td&gt; 字符长度校验(&lt;5):
          &lt;input id=&apos;g&apos;&gt;&lt;/td&gt;
        &lt;td&gt; checkLength(&apos;g&apos;,5,&apos;长度校验&apos;) &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td&gt; 下拉菜单非空校验:
          &lt;select id=&apos;h&apos;&gt;
            &lt;option value=&apos;-1&apos;&gt; 请选择 &lt;/option&gt;
            &lt;option value=&apos;1&apos;&gt; 立项 &lt;/option&gt;
            &lt;option value=&apos;2&apos;&gt; 可研 &lt;/option&gt;
          &lt;/select&gt;&lt;/td&gt;
        &lt;td&gt; checkChooseSelect(&apos;h&apos;,&apos;下拉菜单非空&apos;,&apos;-1&apos;) &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td colspan=&apos;2&apos;&gt;&lt;button onclick=&apos;check()&apos;&gt; 测试表单校验方法 &lt;/button&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;button onclick=&apos;getSelect()&apos;&gt; 得到下拉菜单的值 &lt;/button&gt;&lt;/td&gt;
        &lt;td&gt; getSelectText(sss)和getSelectValue(sss) &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td&gt; 输入下拉菜单的键值字符串(如右所示)
          &lt;input id=&apos;i&apos; value=&apos;1,男;2,女;3,未知&apos;&gt;
          &lt;button onclick=&apos;setSelect()&apos;&gt; 设置下拉菜单的值 &lt;/button&gt;&lt;/td&gt;
        &lt;td&gt; setSelectContent($(&apos;h&apos;),sss) &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;input type=&apos;checkbox&apos; name=&apos;j&apos; value=&apos;aaa1&apos;&gt;
          &lt;input type=&apos;checkbox&apos; name=&apos;j&apos; value=&apos;aaa2&apos;&gt;
          &lt;input type=&apos;checkbox&apos; name=&apos;j&apos; value=&apos;aaa3&apos;&gt;
          &lt;input type=&apos;checkbox&apos; name=&apos;j&apos; value=&apos;aaa4&apos;&gt;
          &lt;button onclick=&apos;getMulti()&apos;&gt; 得到多选选择的id &lt;/button&gt;&lt;/td&gt;
        &lt;td&gt; getCheckedIds(document.getElementsByName(&apos;j&apos;)) &lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;    
&lt;/BODY&gt;
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基本类型与引用类型的区别&lt;br&gt;1.基本类型： string,number,boolean,null,undefined;操作和保存在变量的实际的值。&lt;br&gt;2.引用类型： Function,Array,Object;值保存在内存中，js不允许直接访问内存，在操作的时候，操作的是对象的引用。&lt;/p&gt;
    
    </summary>
    
      <category term="前端面试圣经初级" scheme="http://www.amulong.xin/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9C%A3%E7%BB%8F%E5%88%9D%E7%BA%A7/"/>
    
    
      <category term="javascript" scheme="http://www.amulong.xin/tags/javascript/"/>
    
      <category term="初级" scheme="http://www.amulong.xin/tags/%E5%88%9D%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>前端三剑客-css基础集锦</title>
    <link href="http://www.amulong.xin/2017/07/16/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2-css%E5%9F%BA%E7%A1%80%E9%9B%86%E9%94%A6/"/>
    <id>http://www.amulong.xin/2017/07/16/前端三剑客-css基础集锦/</id>
    <published>2017-07-16T02:21:44.000Z</published>
    <updated>2017-07-17T04:32:44.379Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-CSS-背景"><a href="#1-CSS-背景" class="headerlink" title="1.CSS 背景"></a>1.CSS 背景</h4><p>background:背景占据元素的所有内容区域，包括 padding 和 border，但是不包括元素的 margin。它在 Firefox, Safari ,Opera 以及 IE8 中工作正常，但是 IE6 和 IE7 中，background 没把 border 计算在内。<br><a id="more"></a></p>
<pre><code>//指定填充背景的颜色
//设置背景颜色之外，如果元素底层的背景图不可用，还可以设置一个“回退色”。
//通过在回退色之前增加一个斜杠(/)来实现。
background-color         rgba|#000000|red| green / blue

//引用图片作为背景
//路径是相对于样式所处文件的
background-image         url(&quot;img.png&quot;)

//决定是否重复背景图片
//CSS2中当图片平铺时，会被元素在末端截断。CSS3 引入了两个属性来修正这个问题:
//space: 应用同等数量的空白到图片之间，直到填满整个元素 
//round: 缩小图片直到正好平铺满元素 
background-repeat        no-repeat|repeat-x

//决定背景图是否随页面滚动。
//当设置 background-attachment 为 fixed 时，
//当页面向下滚动时，背景要待在它原来的位置(相对于浏览器来说)。
//也就是不随元素滚动。只能出现在它父元素能达到的区域。
//background-attachment :local; 背景图会随内容的滚动而滚动。
background-attachment    scroll|fixed

//指定元素背景图片的位置
background-position      left top|0 0|50% 50%

//尺寸 
background-size          cover|contain;

//背景原点
//可以从边框，内补白或者内容盒子开始计算 background-position。
background-origin        padding-box|border-box|content-box;

//背景修剪
//background-clip:text结合text-fill-color制作文字渐变效果
h1{font-size:60px;
  background: linear-gradient(to bottom,#FCF,#000);
  -webkit-background-clip:text;
  -webkit-text-fill-color:transparent;
}
background-clip          border-box|padding-box|content-box;

//新增属性background-break
background-break: continuous; 
默认值。忽略盒之间的距离(也就是像元素没有分成多个盒子，依然是一个整体一样) 
background-break: bounding-box; 
把盒之间的距离计算在内
background-break: each-box; 
为每个盒子单独重绘背景
</code></pre><p>技巧：</p>
<p>仿栏：当使用 css 的 float 属性来定位布局元素时，要确保两栏或多栏有相同的长度是比较困难的。如果长度不同，其中一栏的背景会比另外的短，这会破坏整个设计。<br>思路很简单：不再给每列单独设置背景，而是给各列的父元素设置一个背景图。所有栏的设计都包含在这张图片之中。</p>
<p>文本替换：一个适用于任意浏览器的简单方法是，用想用的字体来做一张文本图片，并用这张图片作为背景。这样，文本依然出现在文档标记中以供搜索引擎检索和屏幕浏览器识别，但是在浏览器中就会显示首选的字体。</p>
<blockquote>
<p>{background:url(text.jpg) 0 0 no-repeat; text-indent: -9999px;}</p>
</blockquote>
<h4 id="2-CSS-文本格式"><a href="#2-CSS-文本格式" class="headerlink" title="2.CSS 文本格式"></a>2.CSS 文本格式</h4><pre><code>文本颜色    color    
文本方向    direction              ltr/rtl
文本对齐    text-align             justify/left/right/center
文本修饰    text-decoration        underline/overline/line-through/blink
控制字母    text-transform         capitalize/uppercase/lowercase
文本重写    unicode-bidi           bidi-override
汉字间距    word-spacing    
字符间距    letter-spacing    

 //text-stroke + text-fill-color制作文字镂空效果
 h1{
     font-size:60px;
     -webkit-text-fill-color:transparent;
     -webkit-text-stroke:1px #fff;
 }
 text-stroke 文字描边;
 text-fill-color 文字填充色

//首行缩进
//不影响元素的宽度，适用于block层级的元素；
//ie input缩进有兼容问题。使用padding-left来代替，需要对宽度重新设置。 
text-indent      

//文本阴影
//全兼容写法
//-webkit-transform:translate(2px, 20px);
//-moz-text-shadow:0 0 10px #C06;
//-webkit-text-shadow:0 0 10px #c06;
//text-shadow:0 0 10px #c06;
//filter: Shadow(Color=&apos;green&apos;, Direction=&apos;135&apos;, Strength=&apos;6&apos;)/*Direction阴影的方向*/
//filter: dropshadow(OffX=2, OffY=2, Color=&apos;black&apos;, Positive=&apos;true&apos;);
text-shadow            h-shadow v-shadow blur color

//文本行高
//撑开inline高度的不是文字，而是line-height；
//使用行高垂直居中
//使用行高代替高度避免haslayout
line-height            数字乘字体尺寸来设置行间距

//垂直对齐    
  vertical-align: baseline;sub;super;text-top;text-bottom;middle;bottom;top;
  /* &lt;长度&gt; 值 */
  vertical-align: 10em;4px;
  /* &lt;百分比&gt; 值 */
  vertical-align: 10%;
  {line-height: 30px;vertical-align: -10%;}
  实际上，等同于：{line-height: 30px;vertical-align: -3px;/* = 30px * -10% */  }
  /* 全局值 */
  vertical-align: inherit;initial;unset;

//解决图片下边缘留空隙是由vertical-align和line-height造成的。
//解决方法
1.让vertical-align失效，设置display:block;
2.vertical-align:bottom/middle/top;
3.line-height小于字体大小;
4.font-size:0
//绝对居中div&gt;img
div { line-height: 240px; font-size: 0; }
img { vertical-align: middle; }
//重点：一个inline-block元素，如果里面没有inline内联元素，或者overflow不是visible，
//则该元素的基线就是其margin底边缘，否则，其基线就是元素里面最后一行内联元素的基线。


//处理换行、空格和Tab
/normal（浏览器默认值），即换行符无效、多个空格及Tab被折叠成一个空格来处理、文本内容会自动换行。
//nowrap，文本内容不自动换行，换行符无效、多个空格及Tab被折叠成一个空格来处理。
//pre，换行符有效、多个空格及Tab不会被折叠，文本不会自动换行。可以保留其中的换行及缩进。
//pre-wrap，换行符有效、多个空格及Tab不会被折叠、文本内容会自动换行
//pre-line，换行符有效、多个空格及Tab被折叠成一个空格来处理、文本内容会自动换行
//&lt;pre&gt;的浏览器默认样式中就有white-space: pre;。
white-space            pre/nowrap/pre-wrap/pre-line

//溢出文本显示省略号
//display: inline-block;text-overflow:ellipsis;overflow:hidden;white-space:nowrap;
text-overflow   ellipsis

//一个长单词超出整个容器宽度时是否换行
word-wrap   break-word  指定如果足够长得话，应该换行：

//决定文本的换行点
word-break  break-all    允许在单词内换行。
</code></pre><h4 id="3-CSS-字体"><a href="#3-CSS-字体" class="headerlink" title="3.CSS 字体"></a>3.CSS 字体</h4><pre><code>文本字体 font &quot;font-style font-variant font-weight font-size/line-height font-family&quot;
文本字体系列 font-family    
文本字体大小 font-size    
文本字体样式 font-style     italic/oblique
以小型大写字体或者正常字体显示文本 font-variant    
字体粗细 font-weight normal 400/blod 500
@font-face 规则
@font-face{
    font-family: myFirstFont;
    src: url(sansation_light.woff);
} 
div{font-family:myFirstFont;}
</code></pre><h4 id="4-CSS-链接"><a href="#4-CSS-链接" class="headerlink" title="4.CSS 链接"></a>4.CSS 链接</h4><pre><code>a:link {color:#000000;}      /* 未访问链接*/
a:visited {color:#00FF00;}  /* 已访问链接 */
a:hover {color:#FF00FF;}  /* 鼠标移动到链接上 */
a:active {color:#0000FF;}  /* 鼠标点击时 */
</code></pre><h4 id="5-CSS-列表"><a href="#5-CSS-列表" class="headerlink" title="5.CSS 列表"></a>5.CSS 列表</h4><pre><code>列表项标记浏览器兼容性解决方案
ul{
    list-style-type: none;
    padding: 0px;
    margin: 0px;
}
ul li{
    background-image: url(sqpurple.gif);
    background-repeat: no-repeat;
    background-position: 0px 5px; 
    padding-left: 14px; 
}

list-style    简写属性。用于把所有用于列表的属性设置于一个声明中
list-style-image    将图象设置为列表项标志。
list-style-position    设置列表中列表项标志的位置。
list-style-type    设置列表项标志的类型。
</code></pre><h4 id="6-CSS-盒子模型"><a href="#6-CSS-盒子模型" class="headerlink" title="6.CSS 盒子模型"></a>6.CSS 盒子模型</h4><pre><code>Css盒模型magin外边距+border边框+padding内边距+width内容
当设置background颜色的时候，会覆盖border+padding+width;

width浏览器的兼容性问题
根据 W3C 的规范，元素内容占据的空间是由 width 属性设置的，
w3c中的盒子模型的宽仅包括content;
而内容周围的 padding 和 border 值是另外计算的。
不幸的是，IE5.X 和 6 在怪异模式中使用自己的非标准模型。
这些浏览器的 width 属性不是内容的宽度，
而是内容、内边距和边框的宽度的总和。
ie怪异盒模型的宽包括border*2+padding*2+content;
···
解决方式
不要给元素添加具有指定宽度的内边距，
而是尝试将内边距或外边距添加到元素的父元素和子元素。

浏览器的兼容性问题
IE8 及更早IE版本不支持 填充的宽度和边框的宽度属性设。
···
解决方式
解决IE8及更早版本不兼容问题可以在HTML页面声明 &lt;!DOCTYPE html&gt;即可。
</code></pre><h4 id="7-CSS-边框"><a href="#7-CSS-边框" class="headerlink" title="7.CSS 边框"></a>7.CSS 边框</h4><pre><code>边框样式border-style dotted 点线/dashed 虚线/solid 实线

圆角border-radius
盒阴影 box-shadow &quot;h-shadow v-shadow blur spread color inset&quot;
//全兼容
box {
  -moz-border-radius: 15px; /* Firefox */
  -webkit-border-radius: 15px; /* Safari 和 Chrome */
  border-radius: 15px; /* Opera 10.5+, 以及使用了IE-CSS3的IE浏览器 */

  -moz-box-shadow: 10px 10px 20px #000; /* Firefox */
  -webkit-box-shadow: 10px 10px 20px #000; /* Safari 和 Chrome */
  box-shadow: 10px 10px 20px #000; /* Opera 10.5+, 以及使用了IE-CSS3的IE浏览器 */

  behavior: url(ie-css3.htc); /* 通知IE浏览器调用脚本作用于&apos;box&apos;类 */
}

边界图片 border-image &quot;source slice width outset repeat&quot;
</code></pre><p><a href="/js/ie-css3.htc">ie-css3.htc</a></p>
<h4 id="8-CSS-轮廓"><a href="#8-CSS-轮廓" class="headerlink" title="8.CSS 轮廓"></a>8.CSS 轮廓</h4><pre><code>outline
</code></pre><h4 id="9-CSS-Display-显示-与Visibility（可见性）"><a href="#9-CSS-Display-显示-与Visibility（可见性）" class="headerlink" title="9.CSS Display(显示) 与Visibility（可见性）"></a>9.CSS Display(显示) 与Visibility（可见性）</h4><p>Display</p>
<pre><code>none    此元素不会被显示。
//隐藏元素并脱离文档流

block    此元素将显示为块级元素，此元素前后会带有换行符。
//不设置宽度时，宽度为父元素宽度，不设置高度时，高度为零或者子元素的行高。
  独占一行
  支持宽高
//不支持  vertical-align

inline    默认。此元素会被显示为内联元素，元素前后没有换行符。
//内容撑开宽度
  非独占一行
  不支持宽高
  代码换行被解析成空格
//不支持
//background-position
  clear
  clip
  height | max-height | min-height
  width | max-width | min-width
  overflow
  text-align
  text-indent
  text-overflow

inline-block 行内块元素
//不设置宽度时，内容撑开宽度
  非独占一行
  支持宽高
  代码换行被解析成空格
//不支持clear
//IE兼容
  IE7-浏览器不支持给块级元素设置inline-block样式，解决方法如下：首先将其变成行内元素，使用具有行内元素的特性，然后触发haslayout，使其具有块级元素的特性，如此就可以模拟出inline-block的效果
  div{display:inline-block;*display: inline;zoom: 1;}
</code></pre><p>Visibility<br>    hidden 隐藏但是空间被占据</p>
<h4 id="10-CSS-Positioning-定位"><a href="#10-CSS-Positioning-定位" class="headerlink" title="10.CSS Positioning(定位)"></a>10.CSS Positioning(定位)</h4><pre><code>static  默认值，即没有定位，在文档流中
relative    相对其正常位置。
fixed   相对于浏览器窗口是固定位置。
absolute    相对于最近的已定位父元素或者html
</code></pre><p>px:Fixed 定位在 IE7 和 IE8 下需要描述 !DOCTYPE 才能支持.</p>
<h4 id="11-CSS-Float-浮动"><a href="#11-CSS-Float-浮动" class="headerlink" title="11.CSS Float(浮动)"></a>11.CSS Float(浮动)</h4><p>一个浮动元素会尽量向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。<br>浮动元素之后的元素将围绕它。<br>float浮动：<br>1、块在一排显示（使块元素在一排显示）<br>2、内联支持宽高（使内联元素支持设置高度）<br>3、默认内容撑开宽度（没有宽度自动撑开）前几个与inline-block效果相同<br>4、脱离文档流（浮动元素有可能会覆盖正常文档流中内容）<br>5、提升层级半层（浮动会挤开元素内的内容）</p>
<p>left    元素向左浮动。<br>right   元素向右浮动。</p>
<p>//bug如果父类包含一个浮动元素，浮动元素并不会撑开父类<br>IE浏览器不兼容浮动float的解决办法。<br>一、并排两个div：ie或者ff下对于子div设置float:left的，另外的子div没有设置float-left的话，两个浏览器下会有区别，具体有一个会产生间隙。兼容做法就是都设置float属性。但是记住有设置过float就要将float clear掉，不然下面的div会叠在已float的div上。通常把清除浮动写成单独的<div class="”clear”"></div>放在所有浮动div的最下方。<br>二、在上述1情况中需要设置子div的宽度，假如不设置的话子div的宽度会被默认为父div的100%，这样float根本就产生不了效果。当然还可以用display:inline的方法让两个子div并排,但是这样的话div的宽度设置将会失效(要把子div撑大只能靠里面的元素)。<br>三、ie中父div被设置成特定高度之后，假如里面的浮动子div高度超过了母div设置的高度,ie会自动把母div撑大，但是ff却不能，ff中父div的高度会依然，里面的子层会溢出到外面来。兼容方法：不要设置父级高度。</p>
<h4 id="12-CSS-clip-属性"><a href="#12-CSS-clip-属性" class="headerlink" title="12.CSS clip 属性"></a>12.CSS clip 属性</h4><pre><code>裁剪一张图像：
img {
    position:absolute;
    clip:rect(0px,60px,200px,0px);
}
</code></pre><h4 id="13-CSS-水平对齐-Horizontal-Align"><a href="#13-CSS-水平对齐-Horizontal-Align" class="headerlink" title="13.CSS 水平对齐(Horizontal Align)"></a>13.CSS 水平对齐(Horizontal Align)</h4><pre><code>在IE8中使用margin:auto属性无法正常工作，除非声明 !DOCTYPE

IE5中块元素有一个margin处理BUG。在IE5中，需要添加一些额外的代码
.container{text-align:center;}
.center{
margin-left:auto;
margin-right:auto;
width:70%;
background-color:#b0e0e6;
text-align:left;}

IE8和早期有一个问题，当使用position属性时。
如果一个容器元素（在本例中&lt;div class=&quot;container&quot;&gt;）指定的宽度，
!DOCTYPE声明是缺失，IE8和早期版本会在右边增添17px的margin。
这似乎是一个滚动的预留空间。
使用position属性时始终设置在DOCTYPE声明中！

IE8和早期有一个问题，当使用position属性时。
如果一个容器元素（在本例中&lt;div class=&quot;container&quot;&gt;）指定的宽度，
!DOCTYPE声明是缺失，IE8和早期版本会在右边增添17px的margin。
这似乎是一个滚动的预留空间。
使用position属性时始终设置在DOCTYPE声明中！
float同样如此。
</code></pre><h4 id="14-CSS-组合选择符"><a href="#14-CSS-组合选择符" class="headerlink" title="14.CSS 组合选择符"></a>14.CSS 组合选择符</h4><pre><code>后代选取器(以空格分隔)
子元素选择器(以大于号分隔）
相邻兄弟选择器（以加号分隔）
普通兄弟选择器（以破折号分隔）
:first-child 伪类来选择元素的第一个子元素
q:lang(no) {quotes: &quot;~&quot; &quot;~&quot;;} 注意: 仅当 !DOCTYPE 已经声明时 IE8 支持 :lang.
</code></pre><h4 id="15-CSS-图像透明-不透明"><a href="#15-CSS-图像透明-不透明" class="headerlink" title="15.CSS 图像透明/不透明"></a>15.CSS 图像透明/不透明</h4><pre><code>opacity:0.4;
filter:alpha(opacity=40); /* IE8 及其更早版本 */
</code></pre><h4 id="16-CSS-媒体类型"><a href="#16-CSS-媒体类型" class="headerlink" title="16.CSS 媒体类型"></a>16.CSS 媒体类型</h4><pre><code>@media 规则
@media 规则允许在相同样式表为不同媒体设置不同的样式。
</code></pre><h4 id="17-CSS-属性-选择器"><a href="#17-CSS-属性-选择器" class="headerlink" title="17.CSS 属性 选择器"></a>17.CSS 属性 选择器</h4><pre><code>注意：IE7和IE8需声明!DOCTYPE才支持属性选择器！IE6和更低的版本不支持属性选择器。
</code></pre><h4 id="18-CSS3-渐变（Gradients）"><a href="#18-CSS3-渐变（Gradients）" class="headerlink" title="18.CSS3 渐变（Gradients）"></a>18.CSS3 渐变（Gradients）</h4><pre><code>background: linear-gradient(direction, color-stop1, color-stop2, ...);
background: linear-gradient(angle, color-stop1, color-stop2);
background: radial-gradient(center, shape size, start-color, ..., last-color)

//全兼容写法
.gradient{
    background: #000000;
    background: -moz-linear-gradient(top,  #000000 0%, #ffffff 100%);
    background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#000000), color-stop(100%,#ffffff));
    background: -webkit-linear-gradient(top,  #000000 0%,#ffffff 100%);
    background: -o-linear-gradient(top,  #000000 0%,#ffffff 100%);
    background: -ms-linear-gradient(top,  #000000 0%,#ffffff 100%);
    background: linear-gradient(to bottom,  #000000 0%,#ffffff 100%);
    filter: progid:DXImageTransform.Microsoft.gradient( startColorstr=&apos;#000000&apos;, endColorstr=&apos;#ffffff&apos;,GradientType=0 );
}
:root .gradient{filter:none;}
</code></pre><h4 id="19-CSS3-2D-转换"><a href="#19-CSS3-2D-转换" class="headerlink" title="19.CSS3 2D 转换"></a>19.CSS3 2D 转换</h4><pre><code>//transform 
transform: rotate(30deg);
-ms-transform: rotate(30deg); /* IE 9 */
-webkit-transform: rotate(30deg); /* Safari and Chrome */

translate(50px,100px) 
rotate(30deg)
scale(2,3)
skew(30deg,20deg)
matrix()
</code></pre><h4 id="20-CSS3-3D-转换"><a href="#20-CSS3-3D-转换" class="headerlink" title="20.CSS3 3D 转换"></a>20.CSS3 3D 转换</h4><pre><code>transform 
transform-style:preserve-3d;显示3D
perspective 透视距离
backface-visibility    定义元素在不面对屏幕时是否可见。
</code></pre><h4 id="21-CSS3-过渡"><a href="#21-CSS3-过渡" class="headerlink" title="21.CSS3 过渡"></a>21.CSS3 过渡</h4><pre><code>transition: property duration timing-function delay;
</code></pre><h4 id="22-CSS3-动画"><a href="#22-CSS3-动画" class="headerlink" title="22.CSS3 动画"></a>22.CSS3 动画</h4><pre><code>@keyframes 规则
@keyframes myfirst{
    from {background: red;}
    to {background: yellow;}
}
div
{
    animation-name: myfirst;
    animation-duration: 5s;
    animation-timing-function: linear;
    animation-delay: 2s;
    animation-iteration-count: infinite;
    animation-direction: alternate;
    animation-play-state: running;
}
animation: name duration timing-function delay 
            iteration-count direction fill-mode play-state;
</code></pre><h4 id="23-CSS3-box-sizing"><a href="#23-CSS3-box-sizing" class="headerlink" title="23.CSS3 box-sizing"></a>23.CSS3 box-sizing</h4><pre><code>border-box; 则 padding(内边距) 和 border(边框) 也包含在 width 和 height 中

-moz-box-sizing: content-box;
-webkit-box-sizing: content-box;
-o-box-sizing: content-box;
-ms-box-sizing: content-box;
box-sizing: content-box; 
</code></pre><h4 id="24-CSS3-弹性盒子-Flex-Box"><a href="#24-CSS3-弹性盒子-Flex-Box" class="headerlink" title="24.CSS3 弹性盒子(Flex Box)"></a>24.CSS3 弹性盒子(Flex Box)</h4><pre><code>弹性盒子内容
display: -webkit-flex;
flex-direction: row：横向从左到右排列（左对齐），默认的排列方式。
                row-reverse：反转横向排列（右对齐，从后往前排，最后一项排在最前面。
                column：纵向排列。
                column-reverse：反转纵向排列，从后往前排，最后一项排在最上面。
justify-content: flex-start | flex-end | center | space-between | space-around
align-items: flex-start：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。
             flex-end：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。
             center：弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。
             baseline：如弹性盒子元素的行内轴与侧轴为同一条，则该值与&apos;flex-start&apos;等效。其它情况下，该值将参与基线对齐。
             stretch：如果指定侧轴大小的属性值为&apos;auto&apos;，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照&apos;min/max-width/height&apos;属性的限制。
flex-wrap: nowrap - 默认， 弹性容器为单行。该情况下弹性子项可能会溢出容器。
           wrap - 弹性容器为多行。该情况下弹性子项溢出的部分会被放置到新行，子项内部会发生断行
           wrap-reverse -反转 wrap 排列。
align-content: stretch - 默认。各行将会伸展以占用剩余的空间。
               flex-start - 各行向弹性盒容器的起始位置堆叠。
               flex-end - 各行向弹性盒容器的结束位置堆叠。
               center -各行向弹性盒容器的中间位置堆叠。
               space-between -各行在弹性盒容器中平均分布。
               space-around - 各行在弹性盒容器中平均分布，两端保留子元素与子元素之间间距大小的一半。
弹性子元素属性
order: &lt;integer&gt;：用整数值来定义排列顺序，数值小的排在前面。可以为负值。
完美的居中:
.flex-item {
  margin: auto;
}
align-self: auto：如果&apos;align-self&apos;的值为&apos;auto&apos;，则其计算值为元素的父元素的&apos;align-items&apos;值，如果其没有父元素，则计算值为&apos;stretch&apos;。
            flex-start：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。
            flex-end：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。
            center：弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。
            baseline：如弹性盒子元素的行内轴与侧轴为同一条，则该值与&apos;flex-start&apos;等效。其它情况下，该值将参与基线对齐。
            stretch：如果指定侧轴大小的属性值为&apos;auto&apos;，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照&apos;min/max-width/height&apos;属性的限制。
flex: auto: 计算值为 1 1 auto
      initial: 计算值为 0 1 auto
      none：计算值为 0 0 auto
      inherit：从父元素继承
      [ flex-grow ]：定义弹性盒子元素的扩展比率。
      [ flex-shrink ]：定义弹性盒子元素的收缩比率。
      [ flex-basis ]：定义弹性盒子元素的默认基准值。

兼容写法
.box{
    display: -webkit-flex;  /* 新版本语法: Chrome 21+ */
    display: flex;          /* 新版本语法: Opera 12.1, Firefox 22+ */
    display: -webkit-box;   /* 老版本语法: Safari, iOS, Android browser, older WebKit browsers. */
    display: -moz-box;      /* 老版本语法: Firefox (buggy) */
    display: -ms-flexbox;   /* 混合版本语法: IE 10 */   
}
.flex1 {            
    -webkit-flex: 1;        /* Chrome */  
    -ms-flex: 1             /* IE 10 */  
    flex: 1;                /* NEW, Spec - Opera 12.1, Firefox 20+ */
    -webkit-box-flex: 1     /* OLD - iOS 6-, Safari 3.1-6 */  
    -moz-box-flex: 1;       /* OLD - Firefox 19- */       
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-CSS-背景&quot;&gt;&lt;a href=&quot;#1-CSS-背景&quot; class=&quot;headerlink&quot; title=&quot;1.CSS 背景&quot;&gt;&lt;/a&gt;1.CSS 背景&lt;/h4&gt;&lt;p&gt;background:背景占据元素的所有内容区域，包括 padding 和 border，但是不包括元素的 margin。它在 Firefox, Safari ,Opera 以及 IE8 中工作正常，但是 IE6 和 IE7 中，background 没把 border 计算在内。&lt;br&gt;
    
    </summary>
    
      <category term="前端面试圣经初级" scheme="http://www.amulong.xin/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9C%A3%E7%BB%8F%E5%88%9D%E7%BA%A7/"/>
    
    
      <category term="css" scheme="http://www.amulong.xin/tags/css/"/>
    
      <category term="初级" scheme="http://www.amulong.xin/tags/%E5%88%9D%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>前端三剑客-html标签全解</title>
    <link href="http://www.amulong.xin/2017/07/15/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2-html%E6%A0%87%E7%AD%BE%E5%85%A8%E8%A7%A3/"/>
    <id>http://www.amulong.xin/2017/07/15/前端三剑客-html标签全解/</id>
    <published>2017-07-15T14:36:39.000Z</published>
    <updated>2017-07-17T04:38:07.172Z</updated>
    
    <content type="html"><![CDATA[<h4 id="文档标签"><a href="#文档标签" class="headerlink" title="文档标签"></a>文档标签</h4><p>&lt;!DOCTYPE&gt;     定义文档类型。<br><a id="more"></a></p>
<pre><code>1.HTML 5
&lt;!DOCTYPE html&gt;
2.HTML 4.01 Strict
该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。
&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;
3.HTML 4.01 Transitional
该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。
&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; 
&quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
4.HTML 4.01 Frameset
该 DTD 等同于 HTML 4.01 Transitional，但允许框架集内容。
&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; 
&quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;
5.XHTML 1.0 Strict
该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。必须以格式正确的 XML 来编写标记。
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; 
&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;
6.XHTML 1.0 Transitional
该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。必须以格式正确的 XML 来编写标记。
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;
http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
7.XHTML 1.0 Frameset
该 DTD 等同于 XHTML 1.0 Transitional，但允许框架集内容。
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot; 
&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt;
8.XHTML 1.1
该 DTD 等同于 XHTML 1.0 Strict，但允许添加模型（例如提供对东亚语系的 ruby 支持）。
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;
</code></pre><p>&lt;html&gt;    定义 HTML 文档。<br>&lt;head&gt;    定义关于文档的信息。<br>&lt;meta&gt;    定义关于 HTML 文档的元信息。<br>&lt;title&gt;    定义文档的标题。<br>&lt;link&gt;    定义文档与外部资源的关系。<br>&lt;style&gt;    定义文档的样式信息。<br>&lt;script&gt;    定义客户端脚本。<br>&lt;noscript&gt;    定义针对不支持客户端脚本的用户的替代内容。<br>&lt;body&gt;    定义文档的主体。<br>&lt;base&gt;    定义页面中所有链接的默认地址或默认目标。</p>
<pre><code>&lt;base&gt; 标签为页面上的所有链接规定默认地址或默认目标。
通常情况下，浏览器会从当前文档的 URL 中提取相应的元素来填写相对 URL 中的空白。
使用 &lt;base&gt; 标签可以改变这一点。浏览器随后将不再使用当前文档的 URL，而使用指定的基本 URL 来解析所有的相对 URL。这其中包括 &lt;a&gt;、&lt;img&gt;、&lt;link&gt;、&lt;form&gt; 标签中的 URL。
&lt;base&gt; 标签必须位于 head 元素内部。
</code></pre><p>&lt;div&gt;    定义文档中的节。<br>&lt;span&gt;    定义文档中的节。</p>
<h4 id="语义标签"><a href="#语义标签" class="headerlink" title="语义标签"></a>语义标签</h4><p>&lt;nav&gt;    定义导航链接。<br>&lt;main&gt;  规定文档的主要内容<br>&lt;header&gt;    定义 section 或 page 的页眉。<br>&lt;section&gt;    定义 section。<br>&lt;article&gt;    定义文章。</p>
<pre><code>&lt;article&gt; 标签规定独立的自包含内容。
一篇文章应有其自身的意义，应该有可能独立于站点的其余部分对其进行分发。
&lt;article&gt; 元素的潜在来源：论坛帖子|报纸文章|博客条目|用户评论 
</code></pre><p>&lt;aside&gt;    定义页面内容之外的内容。</p>
<pre><code>&lt;aside&gt; 的内容可用作文章的侧栏。
</code></pre><p>&lt;footer&gt;    定义 section 或 page 的页脚。<br>&lt;address&gt;    定义文档作者或拥有者的联系信息。</p>
<pre><code>&lt;address&gt; 标签定义文档或文章的作者/拥有者的联系信息。
如果 &lt;address&gt; 元素位于 &lt;body&gt; 元素内，则它表示文档联系信息。
如果 &lt;address&gt; 元素位于 &lt;article&gt; 元素内，则它表示文章的联系信息。
&lt;address&gt; 元素中的文本通常呈现为斜体。大多数浏览器会在 address 元素前后添加折行。
</code></pre><h4 id="短语元素标签"><a href="#短语元素标签" class="headerlink" title="短语元素标签"></a>短语元素标签</h4><p>&lt;cite&gt;    定义引用(citation)。<br>&lt;code&gt;    定义计算机代码文本。<br>&lt;em&gt;    定义强调文本。<br>&lt;dfn&gt;    定义定义项目。<br>&lt;strong&gt;    定义强调文本。<br>&lt;samp&gt;    定义计算机代码样本。<br>&lt;kbd&gt;    定义键盘文本。<br>&lt;var&gt;    定义文本的变量部分。</p>
<pre><code>以上元素都是短语元素。虽然这些标签定义的文本大多会呈现出特殊的样式，但实际上，这些标签都拥有确切的语义。
我们并不反对使用它们，但是如果您只是为了达到某种视觉效果而使用这些标签的话，我们建议您使用样式表，那么做会达到更加丰富的效果。
</code></pre><h4 id="文本类标签"><a href="#文本类标签" class="headerlink" title="文本类标签"></a>文本类标签</h4><p>&lt;b&gt;    定义粗体字。<br>&lt;small&gt;    定义小号文本。<br>&lt;i&gt;    定义斜体字。<br>&lt;del&gt;    定义被删除文本。<br>&lt;ins&gt;    定义被插入文本。   </p>
<pre><code>&lt;del&gt;定义文档中已被删除的文本。
&lt;ins&gt; 标签定义已经被插入文档中的文本。
</code></pre><p>&lt;sub&gt;    定义下标文本。<br>&lt;sup&gt;    定义上标文本。<br>&lt;p&gt;    定义段落。<br>&lt;pre&gt;    定义预格式文本。<br>&lt;h1&gt; to &lt;h6&gt;    定义 HTML 标题。<br>&lt;hr&gt;    定义水平线。<br>&lt;br&gt;    定义简单的折行。<br>&lt;big&gt;    定义大号文本。<br>&lt;bdi&gt;    定义文本的文本方向，使其脱离其周围文本的方向设置。</p>
<pre><code>目前只有 Firefox 和 Chrome 支持 &lt;bdi&gt; 标签。
bdi 指的是 bidi 隔离。
&lt;bdi&gt; 标签允许您设置一段文本，使其脱离其父元素的文本方向设置。
在发布用户评论或其他您无法完全控制的内容时，该标签很有用。
属性dir：ltr|rtl
</code></pre><p>&lt;bdo&gt;    定义文字方向。</p>
<pre><code>所有浏览器都支持 &lt;bdo&gt; 标签。
bdo 元素可覆盖默认的文本方向
</code></pre><h4 id="表格元素标签"><a href="#表格元素标签" class="headerlink" title="表格元素标签"></a>表格元素标签</h4><p>&lt;table&gt;    定义表格。<br>&lt;caption&gt;    定义表格标题。</p>
<pre><code>caption 元素定义表格标题。
caption 标签必须紧随 table 标签之后。您只能对每个表格定义一个标题。通常这个标题会被居中于表格之上。
</code></pre><p>&lt;thead&gt;    定义表格中的表头内容。<br>&lt;tbody&gt;    定义表格中的主体内容。<br>&lt;tr&gt;    定义表格中的行。<br>&lt;th&gt;    定义表格中的表头单元格。<br>&lt;td&gt;    定义表格中的单元。<br>&lt;colgroup&gt;    定义表格中供格式化的列组。<br>&lt;col&gt;    定义表格中一个或多个列的属性值。</p>
<pre><code>&lt;col&gt; 标签为表格中一个或多个列定义属性值。可以对全部列应用样式。
只能在 table 或 colgroup 元素中使用 &lt;col&gt; 标签。
水平align：right|left|center|justify|cha
垂直valign：top|middle|bottom|baseline
charoff：规定第一个对齐字符的偏移量。
span：规定 col 元素应该横跨的列数。
</code></pre><p>&lt;tfoot&gt;    定义表格中的表注内容（脚注）。</p>
<h4 id="列表元素标签"><a href="#列表元素标签" class="headerlink" title="列表元素标签"></a>列表元素标签</h4><p>&lt;ul&gt;    定义无序列表。<br>&lt;ol&gt;    定义有序列表。<br>&lt;li&gt;    定义列表的项目。<br>&lt;dl&gt;    定义定义列表。<br>&lt;dd&gt;    定义定义列表中项目的描述。<br>&lt;dt&gt;    定义定义列表中的项目。</p>
<pre><code>&lt;dl&gt;
   &lt;dt&gt;计算机&lt;/dt&gt;
   &lt;dd&gt;用来计算的仪器 ... ...&lt;/dd&gt;
&lt;/dl&gt;
</code></pre><h4 id="表单元素标签"><a href="#表单元素标签" class="headerlink" title="表单元素标签"></a>表单元素标签</h4><p>&lt;form&gt;    定义供用户输入的 HTML 表单。<br>&lt;input&gt;    定义输入控件。</p>
<pre><code>根据不同的 type 属性值，输入字段拥有很多种形式。输入字段可以是文本字段、复选框、掩码后的文本控件、单选按钮、按钮等等。
type:button|checkbox|file|hidden|image|password|radio|reset|submit|text
</code></pre><p>&lt;label&gt;    定义 input 元素的标注。</p>
<pre><code>&lt;label&gt; 标签为 input 元素定义标注（标记）。
label 元素不会向用户呈现任何特殊效果。不过，它为鼠标用户改进了可用性。如果您在 label 元素内点击文本，就会触发此控件。就是说，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。
&lt;label&gt; 标签的 for 属性应当与相关元素的 id 属性相同。
</code></pre><p>&lt;textarea&gt;    定义多行的文本输入控件。<br>&lt;select&gt;    定义选择列表（下拉列表）。<br>&lt;optgroup&gt;    定义选择列表中相关选项的组合。</p>
<pre><code>&lt;optgroup&gt; 标签定义选项组。
optgroup 元素用于组合选项。当您使用一个长的选项列表时，对相关的选项进行组合会使处理更加容易。
</code></pre><p>&lt;option&gt;    定义选择列表中的选项。</p>
<pre><code>option 元素定义下拉列表中的一个选项（一个条目）。
浏览器将 &lt;option&gt; 标签中的内容作为 &lt;select&gt; 标签的菜单或是滚动列表中的一个元素显示。
option 元素位于 select 元素内部。
</code></pre><p>&lt;fieldset&gt;    定义围绕表单中元素的边框。<br>&lt;legend&gt;    定义 fieldset 元素的标题。</p>
<pre><code>&lt;form&gt;
  &lt;fieldset&gt;
    &lt;legend&gt;health information&lt;/legend&gt;
    height: &lt;input type=&quot;text&quot; /&gt;
    weight: &lt;input type=&quot;text&quot; /&gt;
  &lt;/fieldset&gt;
&lt;/form&gt;
fieldset 元素可将表单内的相关元素分组。
</code></pre><p>&lt;button&gt;    定义按钮 (push button)。</p>
<pre><code>&lt;button&gt; 标签定义一个按钮。在 button 元素内部，您可以放置内容，比如文本或图像。这是该元素与使用 input 元素创建的按钮之间的不同之处。
如果在 HTML 表单中使用 button 元素，不同的浏览器会提交不同的值。
Internet Explorer 将提交 &lt;button&gt; 与 &lt;button/&gt; 之间的文本，而其他浏览器将提交 value 属性的内容。
请在 HTML 表单中使用 input 元素来创建按钮。
</code></pre><h4 id="工具类标签"><a href="#工具类标签" class="headerlink" title="工具类标签"></a>工具类标签</h4><p>&lt;canvas&gt;    定义图形。<br>&lt;audio&gt;    定义声音内容。</p>
<pre><code>属性        值            描述
autoplay    autoplay    如果出现该属性，则音频在就绪后马上播放。
controls    controls    如果出现该属性，则向用户显示控件，比如播放按钮。
loop        loop        如果出现该属性，则每当音频结束时重新开始播放。
muted        muted        规定视频输出应该被静音。
preload     preload        如果出现该属性，则音频在页面加载时进行加载，并预备播放。如果使用 &quot;autoplay&quot;，则忽略该属性。
src         url            要播放的音频的 URL。
</code></pre><p>&lt;video&gt;    定义视频。<br>&lt;source&gt;</p>
<pre><code>&lt;source&gt; 标签为媒介元素（比如 &lt;video&gt; 和 &lt;audio&gt;）定义媒介资源。
&lt;source&gt; 标签允许您规定可替换的视频/音频文件供浏览器根据它对媒体类型或者编解码器的支持进行选择。
</code></pre><p>&lt;embed&gt;    定义外部交互内容或插件。<br>&lt;map&gt;    定义图像映射。<br>&lt;area&gt;    定义图像映射内部的区域。</p>
<pre><code>1.area 元素永远嵌套在 map 元素内部。area 元素可定义图像映射中的区域。
2.&lt;img&gt;中的 usemap 属性可引用 &lt;map&gt; 中的 id 或 name 属性（取决于浏览器），应同时向 &lt;map&gt; 添加 id 和 name 属性。
3.area属性：shape    定义区域的形状。default|rect|circ|poly    
</code></pre><p>&lt;iframe&gt;    定义内联框架。</p>
<pre><code>longdesc        URL                规定一个页面，该页面包含了有关 iframe 的较长描述。
name            frame_name        规定 iframe 的名称。
sandbox                            启用一系列对 &lt;iframe&gt; 中内容的额外限制。
scrolling        yes|no|auto     规定是否在 iframe 中显示滚动条。
seamless        seamless        规定 &lt;iframe&gt; 看上去像是包含文档的一部分。
src                URL                规定在 iframe 中显示的文档的 URL。
srcdoc            HTML_code        规定在 &lt;iframe&gt; 中显示的页面的 HTML 内容。
marginheight    pixels            定义 iframe 的顶部和底部的边距。
marginwidth        pixels            定义 iframe 的左侧和右侧的边距。
frameborder        1/0             规定是否显示框架周围的边框。    
height                            规定 iframe 的高度。
width                            定义 iframe 的宽度。
</code></pre><p>&lt;meter&gt;    定义预定义范围内的度量。</p>
<pre><code>&lt;meter&gt; 标签定义已知范围或分数值内的标量测量。也被称为 gauge（尺度）
属性        值        描述
form        form_id    规定 &lt;meter&gt; 元素所属的一个或多个表单。
high        number    规定被视作高的值的范围。
low         number    规定被视作低的值的范围。
max            number    规定范围的最大值。
min            number    规定范围的最小值。
optimum        number    规定度量的优化值。
value        number    必需。规定度量的当前值。
</code></pre><p>&lt;progress&gt;    定义任何类型的任务的进度。</p>
<pre><code>&lt;progress&gt; 标签标示任务的进度（进程）。
max        number    规定任务一共需要多少工作。
value    number    规定已经完成多少任务。
</code></pre><p>&lt;img&gt;    定义图像。<br>&lt;a&gt;    定义锚。</p>
<pre><code>1.download 属性规定被下载的超链接目标。
在 &lt;a&gt; 标签中必须设置 href 属性。
该属性也可以设置一个值来规定下载文件的名称。所允许的值没有限制，浏览器将自动检测正确的文件扩展名并添加到文件 (.img, .pdf, .txt, .html, 等等)。
2.target    规定在何处打开链接文档。
值：_blank|_parent|_self|_top|framename
3.type    规定被链接文档的的 MIME 类型。
</code></pre><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>&lt;!–…–&gt;    定义注释。<br>&lt;blockquote&gt;    定义长的引用。<br>&lt;q&gt; 标签定义短的引用。</p>
<pre><code>&lt;blockquote&gt; 与 &lt;/blockquote&gt; 之间的所有文本都会从常规文本中分离出来，经常会在左、右两边进行缩进（增加外边距），而且有时会使用斜体。也就是说，块引用拥有它们自己的空间。
&lt;q&gt;浏览器经常在引用的内容周围添加引号。
</code></pre><p>&lt;abbr&gt;    定义缩写。</p>
<pre><code>通过对缩写进行标记，您能够为浏览器、拼写检查和搜索引擎提供有用的信息。
可以在 &lt;abbr&gt; 标签中使用全局的 title 属性，这样就能够在鼠标指针移动到 &lt;abbr&gt; 元素上时显示出简称/缩写的完整版本。
</code></pre><p>&lt;figcaption&gt;    定义 figure 元素的标题。<br>&lt;figure&gt;    定义媒介内容的分组，以及它们的标题。</p>
<pre><code>&lt;figure&gt; 标签规定独立的流内容（图像、图表、照片、代码等等）。
figure 元素的内容应该与主内容相关，但如果被删除，则不应对文档流产生影响。
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;文档标签&quot;&gt;&lt;a href=&quot;#文档标签&quot; class=&quot;headerlink&quot; title=&quot;文档标签&quot;&gt;&lt;/a&gt;文档标签&lt;/h4&gt;&lt;p&gt;&amp;lt;!DOCTYPE&amp;gt;     定义文档类型。&lt;br&gt;
    
    </summary>
    
      <category term="前端面试圣经初级" scheme="http://www.amulong.xin/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9C%A3%E7%BB%8F%E5%88%9D%E7%BA%A7/"/>
    
    
      <category term="html" scheme="http://www.amulong.xin/tags/html/"/>
    
      <category term="初级" scheme="http://www.amulong.xin/tags/%E5%88%9D%E7%BA%A7/"/>
    
  </entry>
  
</feed>
